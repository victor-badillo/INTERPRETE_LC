USER MANUAL

LAMBDA-CALCULUS INTERPRETER

AUTHOR: Víctor Nathanael Badillo Aldama

Introduction:
    This is user manual purpose is to ilustrate the user with some examples showing the new developed functionalities and a brief explanation
    of the necessary changes for develop the final code.
    
1.1 Multiline expressions.

    To allow the user to input multiline inputs, there are mainly two solutions: manipulating the string typed by the user or introducing new tokens 
    in the lexical analyzer and new grammatical rules in the syntactic analyzer. In this implementation, the second option was chosen.

    First, a new token DOUBLE_SEMICOLON was created to represent double semicolons. Then, in the syntactic analyzer, this token was added at the end of 
    each rule of the axiom so that every input must end with double semicolons. In the main function, a new function was created to continuously read the 
    input until the line contains a semicolon (;). This is sufficient as a check since semicolons are not used for any other type of input in this 
    interpreter, so their presence indicates the end of a line. If the user accidentally types just a semicolon, a syntax error will be displayed, 
    as explained earlier.

    This solution prevents situations like one expression ended up by double semicolons and a following expression without fishing token which could cause
    problems in other kind of implementations. 

    The implementation also allows the user to enter ";;" without any relevant information. If this happens, the input loop is called again.

    Example:

    let
        a = 11
    in 
        pred a
    ;;

1.2 More complete "Pretty-printer".

    To implement this section, a modification was first made in main.ml to return the type string before the term string. 
    After this small change, lambda.ml was specifically modified in the string_of_term function. 
    This function was subdivided, creating a cascade of functions that call each other according to the expression encountered, 
    adding brackets only when required and removing any excess brackets. The subfunctions created are string_of_appTerm and string_of_atomicTerm. 
    Additionally, excess brackets were removed in string_of_ty.

    In order to obtain a good identation it is necessary to change the return value of string_of_term and directly print in the screen the string_of_term.
    For simplicity me change the name of string_of_term to pretty_printer. Depending on the kind of term, we use a box to encapsulate a part of the output
    and insert the apropiate identation. print_space() is used in order to break line or insert a white space.

2.1 Fixed-point combinator
    ...
    In order to declare recursive functions and not recursive functions without the use of operator in, it is necessary to modify de parser and create
    a rule for this two cases. One rule for let was created in the 'term' rule and one other for letrec.

2.4 Tuples
    lexer.mll: 3 new tokens were included in the sintaxis, curly brackets and comma for separating inside the tuple.
    parser.mly: a new rule is used for indexing one element inside the tuple. This rule will try to math the case for indexing one element. If it was not
    possible, then it will continue normally as before including this rule, trying to match an atomic term. It does not exist any priority inside this rule,
    therefore one '|' is placed before every possible match.
    The new tuple is assigned to a TmTuple term, which must have at least one element.
    Projections are included, so this new term is considered. This will be used as a list of string. We could think that is not a good idea because the Projections
    in tuples uses number for referecing terms but this is done for reusing it for records later on.

2.5 Records

2.6 Variants


Considerations:

Capital letters for naming variables are not valid. The only reason for doing this is follow a general schema and clearness.





TECNIC MANUAL

LAMBDA-CALCULUS INTERPRETER

AUTHOR: Víctor Nathanael Badillo Aldama

Introduction:
    This tecnic manual purpose is to explain what modules from the original implementation have been modified and what
    kind of changes were done to obtain de the final implementation.
    
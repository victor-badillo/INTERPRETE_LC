USER MANUAL

LAMBDA-CALCULUS INTERPRETER

AUTHOR: Víctor Nathanael Badillo Aldama

Introduction:
    This is user manual purpose is to ilustrate the user with some examples showing the new developed functionalities and a brief explanation
    of the necessary changes for develop the final code.
    
1.1 Multiline expressions.

    To allow the user to input multiline inputs, there are mainly two solutions: manipulating the string typed by the user or introducing new tokens 
    in the lexical analyzer and new grammatical rules in the syntactic analyzer. In this implementation, the second option was chosen.

    First, a new token DOUBLE_SEMICOLON was created to represent double semicolons. Then, in the syntactic analyzer, this token was added at the end of 
    each rule of the axiom so that every input must end with double semicolons. In the main function, a new function was created to continuously read the 
    input until the line contains a semicolon (;). This is sufficient as a check since semicolons are not used for any other type of input in this 
    interpreter, so their presence indicates the end of a line. If the user accidentally types just a semicolon, a syntax error will be displayed, 
    as explained earlier.

    This solution prevents situations like one expression ended up by double semicolons and a following expression without fishing token which could cause
    problems in other kind of implementations. 

    The implementation also allows the user to enter ";;" without any relevant information. If this happens, the input loop is called again.

    Example:

    let
        a = 11
    in 
        pred a
    ;;


1.2 Pretty-printer.

    The pretty-printer allows for a much more readable output. First, depending on the command to be executed, a corresponding output is generated for each 
    command, and instead of storing the output in a string, it is printed directly to the screen. Examples of possible outputs are:

    Evaluación:
    - : Type = term

    Bind:
    var : Type = term

    TBind:
    type VarType = Type

    The implementation was done by creating a cascade of functions that call each other depending on the term to be printed. For terms, the surrounding 
    parentheses have been removed, keeping only those that enclose non-atomic terms. Besides achieving the main goal of removing unnecessary parentheses, the 
    output has been organized with good indentation to make the code as readable as possible.

    Regarding the code, the changes required for implementation are straightforward. To begin with, the string_of_ty and string_of_term functions are no longer
    needed in the main module, so their signatures have been removed from the .mli file. This pretty-printer function is called for evaluations and bindings. 
    It divides terms into atomic terms, applications, and others, and applies appropriate indentation based on the type of term being printed. This indentation 
    is achieved using the boxes from OCaml's Format module.

    In addition to removing unnecessary parentheses from terms, parentheses have also been removed from types.

    Examples:

    lambda x : Nat.x;;
    - : Nat -> Nat = lambda x : Nat. x

    letrec sum : Nat -> Nat -> Nat =
    lambda n : Nat. lambda m : Nat. if iszero n then m else succ (sum (pred n) m) in
    sum ;;
    - : Nat -> Nat -> Nat =
    lambda n : Nat.
     lambda m : Nat.
      if iszero n then m
       else (succ (fix (lambda sum : Nat -> Nat -> Nat.
                         lambda n : Nat.
                          lambda m : Nat.
                           if iszero n then m else (succ (sum (pred n) m)))
                    (pred n) m))


2.1 Fixed-point combinator

    Previously, writing functions with recursion required an inconvenient syntax that was not suitable for this interpreter due to type specifications.
    With this new functionality, we can move from this:

    let fix = lambda f.(lambda x. f (lambda y. x x y)) (lambda x. f (lambda y. x x y)) in
    let sumaux =
       lambda f. (lambda n. (lambda m. if (iszero n) then m else succ (f (pred n) m))) in
    let sum = fix sumaux in
    sum 55 45

    to a more convenient syntax:

    letrec sum : Nat -> Nat -> Nat =
       lambda n : Nat. lambda m : Nat. if iszero n then m else succ (sum (pred n) m) in
    sum 55 45

    As can be observed in the new syntax, a new token, letrec, has been introduced, which is used to define recursive functions. This new functionality requires 
    changes in all the main files (lexer.mll, parser.mly, lambda.ml, and lambda.mli). Simply defining letrec is not enough; the fix operator has also been 
    implemented to achieve the goal of self-referential functions. The outputs provided by this input should also be valid outputs. An example of an output used 
    as input that returns the corresponding value of executing the operation:

    (lambda n : Nat.
     lambda m : Nat.
      if iszero n then m
       else (succ (fix (lambda sum : Nat -> Nat -> Nat.
                         lambda n : Nat.
                          lambda m : Nat.
                           if iszero n then m else (succ (sum (pred n) m)))
                    (pred n) m))) 55 45;;

    The necessary changes in parser.mly involve capturing letrec, but it internally works by using fix, and includes fix to recognize and enable examples like the one above to work.
    The following required changes pertain to lambda.ml, modifying the functions typeof, pretty_printer, free_vars, subst, and eval1.

    Examples:

    Multiplication:

    letrec sum : Nat -> Nat -> Nat =
      lambda n : Nat. lambda m : Nat. if iszero n then m else succ (sum (pred n) m)
    in
      letrec prod : Nat -> Nat -> Nat =
        lambda n : Nat. lambda m : Nat. if iszero m then 0 else sum n (prod n (pred m))
        in
          prod 10 50
    ;;

    Fibonacci:

    letrec sum : Nat -> Nat -> Nat =
            lambda n: Nat. lambda m : Nat. if iszero n then m
                  else succ (sum (pred n) m) in
                  letrec fib: Nat -> Nat =
                           lambda n : Nat. if iszero n then 0 else if iszero (pred n) then 1
                                 else sum(fib (pred (pred n))) (fib (pred n)) in
                  fib 7
    ;;

    Factorial:

    letrec sum : Nat -> Nat -> Nat =
     lambda n : Nat. lambda m : Nat. if iszero n then m
         else succ (sum (pred n) m) in
         letrec prod : Nat -> Nat -> Nat =
              lambda n: Nat. lambda m : Nat. if iszero n then 0
                  else sum (prod (pred n) m) m in
                  letrec fac: Nat -> Nat =
                       lambda n : Nat. if iszero n then 1
                           else prod n (fac (pred n))
                   in fac 5
    ;;


2.4 Tuples
    lexer.mll: 3 new tokens were included in the sintaxis, curly brackets and comma for separating inside the tuple.
    parser.mly: a new rule is used for indexing one element inside the tuple. This rule will try to math the case for indexing one element. If it was not
    possible, then it will continue normally as before including this rule, trying to match an atomic term. It does not exist any priority inside this rule,
    therefore one '|' is placed before every possible match.
    The new tuple is assigned to a TmTuple term, which must have at least one element.
    Projections are included, so this new term is considered. This will be used as a list of string. We could think that is not a good idea because the Projections
    in tuples uses number for referecing terms but this is done for reusing it for records later on.

2.5 Records

2.6 Variants


Considerations:

Capital letters for naming variables are not valid. The only reason for doing this is follow a general schema and clearness.





TECNIC MANUAL

LAMBDA-CALCULUS INTERPRETER

AUTHOR: Víctor Nathanael Badillo Aldama

Introduction:
    This tecnic manual purpose is to explain what modules from the original implementation have been modified and what
    kind of changes were done to obtain de the final implementation.
    
USER MANUAL

LAMBDA-CALCULUS INTERPRETER

AUTHOR: Víctor Nathanael Badillo Aldama

Introduction:
    This is user manual purpose is to ilustrate the user with some examples showing the new developed functionalities and a brief explanation
    of the necessary changes for develop the final code.
    
1.1 Multiline expressions.

    To allow the user to input multiline inputs, there are mainly two solutions: manipulating the string typed by the user or introducing new tokens 
    in the lexical analyzer and new grammatical rules in the syntactic analyzer. In this implementation, the second option was chosen.

    First, a new token DOUBLE_SEMICOLON was created to represent double semicolons. Then, in the syntactic analyzer, this token was added at the end of 
    each rule of the axiom so that every input must end with double semicolons. In the main function, a new function was created to continuously read the 
    input until the line contains a semicolon (;). This is sufficient as a check since semicolons are not used for any other type of input in this 
    interpreter, so their presence indicates the end of a line. If the user accidentally types just a semicolon, a syntax error will be displayed, 
    as explained earlier.

    This solution prevents situations like one expression ended up by double semicolons and a following expression without fishing token which could cause
    problems in other kind of implementations. 

    The implementation also allows the user to enter ";;" without any relevant information. If this happens, the input loop is called again.

    Example:

    let
        a = 11
    in 
        pred a
    ;;


1.2 Pretty-printer.

    The pretty-printer allows for a much more readable output. First, depending on the command to be executed, a corresponding output is generated for each 
    command, and instead of storing the output in a string, it is printed directly to the screen. Examples of possible outputs are:

    Evaluación:
    - : Type = term

    Bind:
    var : Type = term

    TBind:
    type VarType = Type

    The implementation was done by creating a cascade of functions that call each other depending on the term to be printed. For terms, the surrounding 
    parentheses have been removed, keeping only those that enclose non-atomic terms. Besides achieving the main goal of removing unnecessary parentheses, the 
    output has been organized with good indentation to make the code as readable as possible.

    Regarding the code, the changes required for implementation are straightforward. To begin with, the string_of_ty and string_of_term functions are no longer
    needed in the main module, so their signatures have been removed from the .mli file. This pretty-printer function is called for evaluations and bindings. 
    It divides terms into atomic terms, applications, and others, and applies appropriate indentation based on the type of term being printed. This indentation 
    is achieved using the boxes from OCaml's Format module.

    In addition to removing unnecessary parentheses from terms, parentheses have also been removed from types.

    Examples:

    lambda x : Nat.x;;
    - : Nat -> Nat = lambda x : Nat. x

    letrec sum : Nat -> Nat -> Nat =
    lambda n : Nat. lambda m : Nat. if iszero n then m else succ (sum (pred n) m) in
    sum ;;
    - : Nat -> Nat -> Nat =
    lambda n : Nat.
     lambda m : Nat.
      if iszero n then m
       else (succ (fix (lambda sum : Nat -> Nat -> Nat.
                         lambda n : Nat.
                          lambda m : Nat.
                           if iszero n then m else (succ (sum (pred n) m)))
                    (pred n) m))



2.1 Fixed-point combinator
    ...
    In order to declare recursive functions and not recursive functions without the use of operator in, it is necessary to modify de parser and create
    a rule for this two cases. One rule for let was created in the 'term' rule and one other for letrec.

2.4 Tuples
    lexer.mll: 3 new tokens were included in the sintaxis, curly brackets and comma for separating inside the tuple.
    parser.mly: a new rule is used for indexing one element inside the tuple. This rule will try to math the case for indexing one element. If it was not
    possible, then it will continue normally as before including this rule, trying to match an atomic term. It does not exist any priority inside this rule,
    therefore one '|' is placed before every possible match.
    The new tuple is assigned to a TmTuple term, which must have at least one element.
    Projections are included, so this new term is considered. This will be used as a list of string. We could think that is not a good idea because the Projections
    in tuples uses number for referecing terms but this is done for reusing it for records later on.

2.5 Records

2.6 Variants


Considerations:

Capital letters for naming variables are not valid. The only reason for doing this is follow a general schema and clearness.





TECNIC MANUAL

LAMBDA-CALCULUS INTERPRETER

AUTHOR: Víctor Nathanael Badillo Aldama

Introduction:
    This tecnic manual purpose is to explain what modules from the original implementation have been modified and what
    kind of changes were done to obtain de the final implementation.
    